# Area Code 轉換測試報告

**測試時間:** 2026-01-15 11:50
**測試目的:** 驗證外部 API 資料的 area_code 轉換邏輯

---

## 📊 測試結果總覽

### 映射表定義

#### POSITION_TO_AREA_MAPPING (精確匹配)
```
A → 控台醫師
B → 手術室
C → 外圍(3F)
D → 外圍(高階)
E → 手術室
F → 外圍(TAE)
```

#### FUZZY_AREA_MAPPING (模糊匹配)
```
A → 控台醫師
B → 手術室
C → 外圍(3F)
D → 手術室          ⚠️ (精確匹配是 "外圍(高階)")
E → 手術室
F → 外圍(TAE)
```

---

## 🧪 轉換測試結果

| Summary | 姓名 | Area Code | 匹配方式 |
|---------|------|-----------|---------|
| `陳柏羽/A` | 陳柏羽 | 控台醫師 | 精確匹配 ✅ |
| `陳柏羽/B` | 陳柏羽 | 手術室 | 精確匹配 ✅ |
| `陳柏羽/C` | 陳柏羽 | 外圍(3F) | 精確匹配 ✅ |
| `陳柏羽/D` | 陳柏羽 | 外圍(高階) | 精確匹配 ✅ |
| `陳柏羽/D1` | 陳柏羽 | **手術室** | **模糊匹配 🚨** |
| `陳柏羽/D2` | 陳柏羽 | **手術室** | **模糊匹配 🚨** |
| `陳柏羽/D(外圍)` | 陳柏羽 | 外圍(高階) | 精確匹配 ✅ |
| `陳柏羽/E` | 陳柏羽 | 手術室 | 精確匹配 ✅ |
| `陳柏羽/F` | 陳柏羽 | 外圍(TAE) | 精確匹配 ✅ |
| `范守仁/B` | 范守仁 | 手術室 | 精確匹配 ✅ |
| `測試醫師/A(控台)` | 測試醫師 | 控台醫師 | 精確匹配 ✅ |
| `測試醫師/手術室` | 測試醫師 | 手術室 | 返回原值 ℹ️ |
| `測試醫師/未知區域` | 測試醫師 | 未知區域 | 返回原值 ℹ️ |

---

## 🔬 詳細分析

### 案例 1: `陳柏羽/D` (精確匹配)
```
區域部分: "D"
移除括號: "D"
第一字母: "D"
✅ 精確匹配: "D" → "外圍(高階)"
→ 最終結果: 姓名="陳柏羽", Area Code="外圍(高階)"
```

### 案例 2: `陳柏羽/D1` (模糊匹配) ⚠️
```
區域部分: "D1"
移除括號: "D1"
第一字母: "D"
❌ 精確匹配失敗: "D1" 不在映射表中
⚠️ 模糊匹配: "D" → "手術室"
🚨 警告: 如果是 "D" 會精確匹配到 "外圍(高階)"
         但 "D1" 會模糊匹配到 "手術室"
→ 最終結果: 姓名="陳柏羽", Area Code="手術室"
```

### 案例 3: `陳柏羽/D2` (模糊匹配) ⚠️
```
區域部分: "D2"
移除括號: "D2"
第一字母: "D"
❌ 精確匹配失敗: "D2" 不在映射表中
⚠️ 模糊匹配: "D" → "手術室"
🚨 警告: 如果是 "D" 會精確匹配到 "外圍(高階)"
         但 "D2" 會模糊匹配到 "手術室"
→ 最終結果: 姓名="陳柏羽", Area Code="手術室"
```

### 案例 4: `陳柏羽/D(外圍)` (精確匹配)
```
區域部分: "D(外圍)"
移除括號: "D"
第一字母: "D"
✅ 精確匹配: "D" → "外圍(高階)"
→ 最終結果: 姓名="陳柏羽", Area Code="外圍(高階)"
```

---

## 🚨 關鍵發現

### 問題: D 開頭的區域代碼映射不一致

**現象:**
- `D` (精確匹配) → `"外圍(高階)"`
- `D1`, `D2` (模糊匹配) → `"手術室"`

**影響:**
這可能導致以下問題:
1. 相同醫師在不同日期有不同的 area_code
2. 如果外部 API 某天返回 `"陳柏羽/D"`,某天返回 `"陳柏羽/D1"`,會被轉換成不同的區域
3. 護理長可能會困惑為什麼同一位醫師的區域代碼會變化

**範例場景:**
```
第一天: 外部 API 返回 "陳柏羽/D"
        → 儲存為 area_code="外圍(高階)"

第二天: 外部 API 返回 "陳柏羽/D1"  
        → 儲存為 area_code="手術室"

結果: 同一位醫師在不同天有不同的區域代碼!
```

---

## 💡 建議修復方案

### 選項 1: 統一為「外圍(高階)」

修改 `FUZZY_AREA_MAPPING`:

```python
FUZZY_AREA_MAPPING = {
    'A': '控台醫師',
    'B': '手術室', 
    'C': '外圍(3F)',
    'D': '外圍(高階)',  # 修改: 與精確匹配一致
    'E': '手術室',
    'F': '外圍(TAE)',
}
```

**優點:**
- D 開頭的所有變體都會轉換為「外圍(高階)」
- 保持一致性

**缺點:**
- 如果 D1, D2 實際上應該是「手術室」,這個修改就不對

---

### 選項 2: 統一為「手術室」

修改 `POSITION_TO_AREA_MAPPING`:

```python
POSITION_TO_AREA_MAPPING = {
    'A': '控台醫師',
    'B': '手術室',
    'C': '外圍(3F)',
    'D': '手術室',      # 修改: 與模糊匹配一致
    'E': '手術室',
    'F': '外圍(TAE)',
}
```

**優點:**
- D 開頭的所有變體都會轉換為「手術室」
- 保持一致性

**缺點:**
- 如果 D 實際上應該是「外圍(高階)」,這個修改就不對

---

### 選項 3: 保持現狀並記錄

如果 D 和 D1/D2 確實應該對應不同的區域:

1. 在文件中明確說明這個設計
2. 增加更多 debug 日誌
3. 確保護理長知道這個行為
4. 考慮在前端顯示時增加提示

---

## 🔍 Debug 建議

### 1. 檢查外部 API 實際返回的資料

```bash
# 注意: 目前外部 API 返回 404,可能需要確認正確的端點
curl "https://docdutyapi.zeabur.app/schedule/20260116/20260122"
```

### 2. 查看資料庫中的實際資料

```sql
-- 查看所有 D 開頭的 summary
SELECT DISTINCT summary, area_code, COUNT(*) as count
FROM day_shift_doctors
WHERE summary LIKE '%/D%'
GROUP BY summary, area_code
ORDER BY summary;

-- 查看是否有同一位醫師有不同的 area_code
SELECT name, area_code, COUNT(DISTINCT area_code) as area_count
FROM day_shift_doctors
GROUP BY name
HAVING COUNT(DISTINCT area_code) > 1;
```

### 3. 增加日誌

在 `extract_name_and_area_from_summary` 中增加:

```python
logger.debug(f"解析 summary: {summary}")
logger.debug(f"  - 精確匹配: {area_letter} → {exact_match}")
logger.debug(f"  - 模糊匹配: {first_letter} → {fuzzy_match}")
logger.debug(f"  - 最終結果: {name}, {area_code}")
```

---

## ✅ 測試結論

1. **轉換邏輯運作正常** - 精確匹配和模糊匹配都按預期工作
2. **發現不一致問題** - D 開頭的區域代碼在精確匹配和模糊匹配中有不同的結果
3. **需要決策** - 需要根據實際業務需求決定如何處理 D 的映射

---

## 📝 下一步行動

1. ✅ **確認外部 API 實際返回的 summary 格式**
   - 是否會出現 `D1`, `D2` 等變體?
   - 還是只會出現 `D`?

2. ✅ **檢查資料庫中的歷史資料**
   - 查看是否有 D 開頭的不同變體
   - 確認是否有醫師的 area_code 不一致

3. ✅ **決定修復方案**
   - 選擇選項 1, 2 或 3
   - 根據實際需求調整映射表

4. ✅ **測試修復**
   - 修改後重新執行測試
   - 確認所有案例都符合預期

---

**測試執行者:** Antigravity AI Assistant
**測試狀態:** ✅ 完成
**發現問題:** 1 個 (D 映射不一致)
**建議優先級:** 高 (可能影響資料一致性)
